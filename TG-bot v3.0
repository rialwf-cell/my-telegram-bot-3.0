#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
–ë–æ—Ç‚Äë—Å–µ—Ä–≤–∏—Å ¬´–ö–∞–Ω–∞–ª + –ü—Ä–µ–¥–ª–æ–∂–∫–∏ + –õ–∞–±–∏—Ä–∏–Ω—Ç¬ª
(Python‚Äëtelegram‚Äëbot v20.7+, Python‚ÄØ3.10+)

*   –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–±–µ–¥/–ø–æ—Ä–∞–∂–µ–Ω–∏–π –≤ —Å–æ–æ–±—â–µ–Ω–∏—è—Ö –∏–≥—Ä–æ–∫–∞
*   –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä ¬´NICKNAMES¬ª —Ç–µ–ø–µ—Ä—å –ø–æ–¥–º–µ–Ω—è–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º.
"""

# --------------------------------------------------
# 1. –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
# --------------------------------------------------
import os
import json
import re
import asyncio
import random
import logging                 # <-- –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

from datetime import datetime, timedelta
from collections import defaultdict

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ReplyKeyboardMarkup,
)
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    ConversationHandler,
    filters,
)

# --------------------------------------------------
# 2. –ù–∞—Å—Ç—Ä–æ–π–∫–∏
# --------------------------------------------------
BOT_TOKEN = "************************"   # ‚Üê –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ç–æ–∫–µ–Ω —Å–≤–æ–µ–≥–æ –±–æ—Ç–∞

ADMIN_IDS = [*************]              # ‚Üê ID(—ã) –∞–¥–º–∏–Ω–æ–≤
CHANNEL_USERNAME = "***************"  # ‚Üê username –∫–∞–Ω–∞–ª–∞ –±–µ–∑ @
CHANNEL_CHAT_ID = -100**********     # ‚Üê ID –∫–∞–Ω–∞–ª–∞
GROUP_CHAT_ID = -100************       # ‚Üê ID –≥—Ä—É–ø–ø—ã –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–∫
SUGGESTION_TOPIC_ID = ****           # ‚Üê ID —Ç–µ–º—ã –≤ –≥—Ä—É–ø–ø–µ
ADMIN_CHAT_ID = GROUP_CHAT_ID
COMMENTS_CHAT_ID = -100************    # ‚Üê —á–∞—Ç —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏ (–Ω–µ –º–µ–Ω—è—Ç—å)

# ------- –ù–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞ (—É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã) -------
LABYRINTH_RULES, LABYRINTH_START, LABYRINTH_GAME = range(3)
# ----------------------------------------------------------------

# 8.  HELPER‚Äë–§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–õ–û–ñ–ï–ù–ò–ô –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
# --------------------------------------------------------------------------
async def show_rules(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    –í—ã–≤–æ–¥–∏–º –ø—Ä–∞–≤–∏–ª–∞ –∏ —Å—Ç–∞–≤–∏–º –∫–Ω–æ–ø–∫—É ¬´–°—Ç–∞—Ä—Ç¬ª, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥
    –ø–µ—Ä–µ–π—Ç–∏ –∫ —Ä–µ–∞–ª—å–Ω–æ–º—É –∏–≥—Ä–æ–≤–æ–º—É –ø—Ä–æ—Ü–µ—Å—Å—É.
    """
    # –ü—Ä–µ–¥—á–µ–∫ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞: –Ω–µ –ø—É—Å–∫–∞–µ–º –≤ –∏–≥—Ä—É –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤ —Ç–æ—Ç –∂–µ –¥–µ–Ω—å
    if LABYRINTH_DAILY_LIMIT_ENABLED:
        user = update.effective_user
        if user:
            state = load_laby_state(user.id)
            today = datetime.now().strftime("%Y-%m-%d")
            if state.last_labyrinth == today:
                await update.message.reply_text(
                    "‚è≥ –í—ã —É–∂–µ –∏–≥—Ä–∞–ª–∏ —Å–µ–≥–æ–¥–Ω—è. –í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –∑–∞–≤—Ç—Ä–∞!",
                    parse_mode="HTML",
                    reply_markup=USER_KEYBOARD,
                )
                return ConversationHandler.END

    rules_text = (
        "üìú <b>–ü—Ä–∞–≤–∏–ª–∞ –ü–æ–∂–∏–ª–æ–≥–æ —Ç—Ä–∏–ø–∞</b>\n\n"
        "‚Ä¢ –í—ã –ø–æ–ø–∞–¥–∞–µ—Ç–µ –≤ –æ–ø–∞—Å–Ω—ã–π —Ç—Ä–∏–ø, –≥–¥–µ –∫–∞–∂–¥—ã–π —Ö–æ–¥ –º–æ–∂–µ—Ç –æ–±–µ—Ä–Ω—É—Ç—å—Å—è\n"
        "  –ø–æ–±–µ–¥–æ–π –∏–ª–∏ –ø–æ—Ä–∞–∂–µ–Ω–∏–µ–º.\n"
        "‚Ä¢ –ü—Ä–∏ –∫–∞–∂–¥–æ–º —Ö–æ–¥–µ –≤—ã–±–µ—Ä–∏—Ç–µ: ¬´–ù–∞–ª–µ–≤–æ¬ª, ¬´–í–ø–µ—Ä–µ–¥¬ª, ¬´–ù–∞–ø—Ä–∞–≤–æ¬ª.\n"
        "  –í –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –º–æ–∂–Ω–æ –ø–µ—Ä–µ–π—Ç–∏ –∫ ¬´–°–º–µ—Ä—Ç–∏¬ª –∏–ª–∏ ¬´–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é¬ª.\n"
        "‚Ä¢ –í –ø—Ä–æ—Ü–µ—Å—Å–µ –º–æ–≥—É—Ç –≤–æ–∑–Ω–∏–∫–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è\n"
        "  (–ø–æ–ª—É—á–µ–Ω–∏–µ –∑–æ–ª–æ—Ç–∞, –ø–æ—Ç–µ—Ä—è HP, –∞—Ç–∞–∫–∏ –º–æ–Ω—Å—Ç—Ä–æ–≤ –∏ —Ç.–¥.). –•–æ–¥ –≤–ª–∏—è–µ—Ç –Ω–∞ HP.\n"
        "‚Ä¢ HP‚ÄØ‚â§‚ÄØ0 ‚Äì –ø–æ—Ä–∞–∂–µ–Ω–∏–µ.\n"
        "‚Ä¢ –ü—Ä–æ–π–¥–∏—Ç–µ 10 —Ö–æ–¥–æ–≤ ‚Äì –ø–æ–±–µ–¥–∞.\n\n"
        "–ì–æ—Ç–æ–≤—ã —Å—Ç–∞—Ç—å –≥–µ—Ä–æ–µ–º? –ù–∞–∂–º–∏—Ç–µ ¬´–°—Ç–∞—Ä—Ç¬ª, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å."
    )
    markup = ReplyKeyboardMarkup(
        [["–°—Ç–∞—Ä—Ç"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
    )
    await update.message.reply_text(rules_text, parse_mode="HTML", reply_markup=markup)
    return LABYRINTH_START

async def wait_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª ¬´–°—Ç–∞—Ä—Ç¬ª, –∑–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É.
    –ò–Ω–∞—á–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∫ ¬´–°—Ç–∞—Ä—Ç¬ª.
    """
    text = (update.message.text or "").strip().lower()
    if text == "—Å—Ç–∞—Ä—Ç":
        # –ú—ã –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–æ–≥–∏–∫—É –ø–æ–ª–Ω–æ–π –∏–≥—Ä—ã
        return await start_labyrinth(update, context)  # —É–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç LABYRINTH_GAME
    elif text == "–≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>",
            parse_mode="HTML",
            reply_markup=USER_KEYBOARD,
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            "–ù–∞–∂–º–∏—Ç–µ <b>¬´–°—Ç–∞—Ä—Ç¬ª</b>, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏–≥—Ä–æ–≤—É—é —Å–µ—Å—Å–∏—é.",
            parse_mode="HTML",
            reply_markup=ReplyKeyboardMarkup(
                [["–°—Ç–∞—Ä—Ç"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
            ),
        )
        return LABYRINTH_START

# –§–∞–π–ª—ã
STATS_FILE = "bot_stats.json"
USERS_FILE = "bot_users.json"
POSTS_FILE = "bot_posts.json"
MIRROR_MAP_FILE = "mirror_map.json"
PROMOS_FILE = "promos.txt"
PROMO_STATS_FILE = "promo_stats.json"
COMMENT_PROMOS_FILE = "comment_promos.txt"

# –ü–æ—Ä–æ–≥ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –¥–ª—è –¥—Ä–æ–ø–∞ –ø—Ä–æ–º–æ–∫–æ–¥–∞ –≤ —á–∞—Ç–µ (1 —Ä–∞–∑ –≤ –¥–µ–Ω—å)
COMMENT_DROP_THRESHOLD = 24 # –£–∫–∞–∂–∏—Ç–µ –ª—é–±–æ–µ –Ω—É–∂–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º –±–æ—Ç –≤—ã–¥–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç


# –õ–∞–±–∏—Ä–∏–Ω—Ç
LABYRINTH_MAX_STEPS = 10
LABYRINTH_START_HP = 10
LABYRINTH_DAILY_LIMIT_ENABLED = False # –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ 1‚Äë—Ä–∞–∑‚Äë–≤‚Äë—Å—É—Ç–∫–∏ True \ False
LABYRINTH_PROMO_LIMIT_PER_DAY = 5

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
ADMIN_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"],
        ["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏"],
        ["–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º"],
    ],
    resize_keyboard=True,
)

USER_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å", "–ò–≥—Ä–∞—Ç—å –≤ –ü–æ–∂–∏–ª–æ–π —Ç—Ä–∏–ø"],
        ["–ü–æ–º–æ—â—å", "üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä"],
    ],
    resize_keyboard=True,
)

# –°–æ—Å—Ç–æ—è–Ω–∏—è ConversationHandler
GET_TEXT, GET_BUTTONS, LABYRINTH_GAME = range(3)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# 2.–õ–û–ì–ò–†–û–í–ê–ù–ò–ï
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# --------------------------------------------------
# 4. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
# --------------------------------------------------
def load_json(path: str, default):
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.warning(f"Error reading {path}: {e}")
    return default


def save_json(path: str, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def load_stats():
    data = load_json(
        STATS_FILE,
        {
            "total_suggestions": 0,
            "published": 0,
            "rejected": 0,
            "today_suggestions": 0,
            "today_date": datetime.now().strftime("%Y-%m-%d"),
            "users_count": 0,
            "active_users": set(),
        },
    )
    if isinstance(data.get("active_users", []), list):
        data["active_users"] = set(data["active_users"])
    return data


def save_stats(stats):
    s = stats.copy()
    s["active_users"] = list(s["active_users"])
    save_json(STATS_FILE, s)


def load_users():
    return load_json(USERS_FILE, {})


def save_users(users):
    save_json(USERS_FILE, users)

async def handle_group_message_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if not update.message or update.message.chat.id != COMMENTS_CHAT_ID:
            return

        # –ñ—É—Ä–Ω–∞–ª–∏—Ä—É–µ–º –≤—Ö–æ–¥
        is_auto = getattr(update.message, "is_automatic_forward", False)
        logger.info(f"PromoChat: enter handle_group_message_stats mid={update.message.message_id}, is_auto={is_auto}")
        if is_auto:
            logger.info("PromoChat: skip automatic_forward")
            return

        # –ï—Å–ª–∏ —ç—Ç–æ –∞–≤—Ç–æ‚Äë–ø–µ—Ä–µ—Å–ª–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–∑–µ—Ä–∫–∞–ª–æ –ø–æ—Å—Ç–∞) ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        if getattr(update.message, "is_automatic_forward", False):
            return

        # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
        logger.info(
            f"PromoChat: got user message in COMMENTS_CHAT_ID, msg_id={update.message.message_id}, "
            f"from={update.effective_user.id if update.effective_user else 'unknown'}"
        )

        user = update.effective_user
        if not user:
            return

        users = load_users()
        u = users.setdefault(str(user.id), {
            "name": user.first_name,
            "first_seen": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "suggestions_count": 0,
        })
        u["name"] = u.get("name") or user.first_name
        today = datetime.now().strftime("%Y-%m-%d")
        msg_counts = u.setdefault("msg_counts", {})
        msg_counts[today] = msg_counts.get(today, 0) + 1
        save_users(users)

        # ===== –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Å—á—ë—Ç—á–∏–∫ —á–∞—Ç–∞ –∏ –¥–Ω–µ–≤–Ω–æ–π –¥—Ä–æ–ø –ø—Ä–æ–º–æ–∫–æ–¥–∞ =====
        stats = load_json(PROMO_STATS_FILE, {})
        chat_last_date = stats.get("chat_last_date")
        if chat_last_date != today:
            stats["chat_last_date"] = today
            stats["chat_comments_count"] = 0
            stats["chat_dropped_today"] = False
            logger.info("PromoChat: –ù–æ–≤—ã–π –¥–µ–Ω—å ‚Äî —Å—á—ë—Ç—á–∏–∫–∏ –æ–±–Ω—É–ª–µ–Ω—ã")

        stats["chat_comments_count"] = stats.get("chat_comments_count", 0) + 1

        logger.info(
            f"PromoChat: today={today}, count={stats['chat_comments_count']}, "
            f"dropped={stats.get('chat_dropped_today', False)}, threshold={COMMENT_DROP_THRESHOLD}"
        )

        if stats.get("chat_comments_count", 0) >= COMMENT_DROP_THRESHOLD and not stats.get("chat_dropped_today", False):
            promo = get_comment_promo()
            if promo:
                try:
                    await context.bot.send_message(
                        chat_id=COMMENTS_CHAT_ID,
                        text=f"üéâ –°–ø–∞—Å–∏–±–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å! –î–µ—Ä–∂–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥: <code>{promo}</code>",
                        parse_mode="HTML",
                        reply_to_message_id=update.message.message_id,
                    )
                except Exception as e:
                    logger.warning(f"PromoChat: reply_to failed, sending standalone: {e}")
                    await context.bot.send_message(
                        chat_id=COMMENTS_CHAT_ID,
                        text=f"üéâ –°–ø–∞—Å–∏–±–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å! –î–µ—Ä–∂–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥: <code>{promo}</code>",
                        parse_mode="HTML",
                    )
                stats["chat_dropped_today"] = True
                logger.info(f"PromoChat: dropped promo '{promo}' to chat")

        save_json(PROMO_STATS_FILE, stats)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_group_message_stats: {e}")
# ... existing code ...

async def promo_chat_debug(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user or user.id not in ADMIN_IDS:
        return
    today = datetime.now().strftime("%Y-%m-%d")
    stats = load_json(PROMO_STATS_FILE, {})
    args = context.args or []

    # init - –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–Ω–µ–≤–Ω—ã–µ –ø–æ–ª—è
    if args and args[0] == "init":
        stats["chat_last_date"] = today
        stats["chat_comments_count"] = stats.get("chat_comments_count", 0)
        stats["chat_dropped_today"] = stats.get("chat_dropped_today", False)
        save_json(PROMO_STATS_FILE, stats)
        await update.message.reply_text("PromoChat: –ø–æ–ª—è –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")

    # inc - –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç —Å—á—ë—Ç—á–∏–∫–∞ –∏ –ø–æ–ø—ã—Ç–∫–∞ –¥—Ä–æ–ø–∞
    if args and args[0] == "inc":
        if stats.get("chat_last_date") != today:
            stats["chat_last_date"] = today
            stats["chat_comments_count"] = 0
            stats["chat_dropped_today"] = False
        stats["chat_comments_count"] = stats.get("chat_comments_count", 0) + 1
        # –ø—Ä–æ–±—É–µ–º –¥—Ä–æ–ø–Ω—É—Ç—å
        drop_done = False
        if stats["chat_comments_count"] >= COMMENT_DROP_THRESHOLD and not stats.get("chat_dropped_today", False):
            promo = get_comment_promo()
            if promo:
                await update.message.reply_text(
                    f"–¢–ï–°–¢–û–í–´–ô –î–†–û–ü –í –õ–ò–ß–ö–£: <code>{promo}</code>", parse_mode="HTML"
                )
                stats["chat_dropped_today"] = True
                drop_done = True
        save_json(PROMO_STATS_FILE, stats)
        await update.message.reply_text(
            f"PromoChat: count={stats['chat_comments_count']}, dropped_today={stats['chat_dropped_today']}, drop_now={drop_done}"
        )

    info = (
        f"PromoChat DEBUG\n"
        f"chat_last_date: {stats.get('chat_last_date')}\n"
        f"chat_comments_count: {stats.get('chat_comments_count')}\n"
        f"chat_dropped_today: {stats.get('chat_dropped_today')}\n"
        f"threshold: {COMMENT_DROP_THRESHOLD}\n"
        f"today: {today}\n"
        f"args: {args}\n"
    )
    await update.message.reply_text(f"<code>{info}</code>", parse_mode="HTML")

def load_posts():
    return load_json(POSTS_FILE, {})


def save_posts(posts):
    save_json(POSTS_FILE, posts)


def load_mirror_map():
    return load_json(MIRROR_MAP_FILE, {})


def save_mirror_map(m):
    save_json(MIRROR_MAP_FILE, m)


def get_daily_promo() -> str | None:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–∏–Ω –ø—Ä–æ–º–æ–∫–æ–¥ –Ω–∞ –¥–µ–Ω—å, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ."""
    stats = load_json(PROMO_STATS_FILE, {})
    today = datetime.now().strftime("%Y-%m-%d")
    if stats.get("last_date") != today:
        stats["last_date"] = today
        stats["count"] = 0
    if stats.get("count", 0) >= LABYRINTH_PROMO_LIMIT_PER_DAY:
        save_json(PROMO_STATS_FILE, stats)
        return None
    if not os.path.exists(PROMOS_FILE):
        return None
    with open(PROMOS_FILE, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f if l.strip()]
    if not lines:
        return None
    promo = lines.pop(0)
    with open(PROMOS_FILE, "w", encoding="utf-8") as f:
        f.writelines(l + "\n" for l in lines)
    stats["count"] = stats.get("count", 0) + 1
    save_json(PROMO_STATS_FILE, stats)
    return promo


# --------------------------------------------------
# 5. –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã –∏ —Å–æ–æ–±—â–µ–Ω–∏—è
# --------------------------------------------------
def load_messages() -> dict:
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ `messages.json`.
    –ï—Å–ª–∏ —Ñ–∞–π–ª/–ø–∞–ø–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç ‚Äì —Å–æ–∑–¥–∞—ë—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ ¬´–∑–∞–≥–ª—É—à–∫–∏¬ª,
    —á—Ç–æ–±—ã `random.choice()` –Ω–µ –ø–∞–¥–∞–ª —Å `IndexError`. """
    msgs = load_json("messages.json", {})

    # ---------- –ì—Ä–µ–π—Ç–∏–Ω–≥–∏ ----------
    if "greetings" not in msgs or not msgs["greetings"]:
        msgs["greetings"] = [
            {
                "first_time": {"text": "–ü—Ä–∏–≤–µ—Ç, NICKNAMES! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç.", "image": ""},
                "subsequent": {"text": "–¢—ã —É–∂–µ –∑–¥–µ—Å—å, NICKNAMES.", "image": ""},
            }
        ]

    # ---------- –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã ----------
    if "placeholders" not in msgs:
        msgs["placeholders"] = {
            "NICKNAMES": ["Alex", "Masha", "Ivan"],
            "NICK_WB": ["–ë–æ—Ä–∏—Å", "–ö–∏—Ä–∏–ª–ª"],
            "NICK_EP": ["–≠–ª—å—Ñ", "–ì–Ω–æ–º"],
            "NICK_WINX": ["–í–æ–∏–Ω", "–ì–µ—Ä–æ–π"],
        }

    # ---------- –°–æ–±—ã—Ç–∏—è 1‚Äë6 + special ----------
    if "events" not in msgs:
        msgs["events"] = {}
    for key in ("1", "2", "3", "4", "5", "6", "special"):
        if key not in msgs["events"]:
            msgs["events"][key] = []

        if not msgs["events"][key]:
            msgs["events"][key] = [
                {"text": f"–ü–æ–∫–∞–∑–∞–Ω–æ —Å–æ–±—ã—Ç–∏–µ {key} (–∑–∞–≥–ª—É—à–∫–∞).", "image": ""}
            ]

    # ---------- –ü–æ—Ä–∞–∂–µ–Ω–∏—è / –ø–æ–±–µ–¥—ã ----------
    for key in ("defeat1", "defeat2", "defeat", "victory"):
        if key not in msgs:
            msgs[key] = []

        if not msgs[key]:
            msgs[key] = [
                {"text": f"–ó–∞–≥–ª—É—à–∫–∞ {key}.", "image": ""},
            ]

    return msgs


# –†–µ–≥—É–ª—è—Ä–∫–∞ –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤ (—Ä–µ–≥–∏—Å—Ç—Ä –±–µ–∑ —Ä–∞–∑–Ω–∏—Ü—ã)
PMS_RE = re.compile(r"\b(NICK_(?:WB|EP|WINX|NAMES)|NICKNAMES)\b", re.IGNORECASE)


def resolve_placeholders(text: str, placeholders: dict) -> str:
    """–ü–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –≤ —Å—Ç—Ä–æ–∫—É —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤."""
    matches = list(PMS_RE.finditer(text))
    if not matches:
        return text

    used_values = {}

    def merged_nicknames_pool() -> list[str]:
        # –°–æ–±–∏—Ä–∞–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö —Å–ø–∏—Å–∫–æ–≤ NICK_* –∫—Ä–æ–º–µ —Å–∞–º–æ–≥–æ NICKNAMES
        merged = []
        for k, v in placeholders.items():
            ku = k.upper()
            if ku.startswith("NICK_") and ku != "NICKNAMES" and isinstance(v, list):
                merged.extend(v)
        # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã, —Å–æ—Ö—Ä–∞–Ω—è—è –ø–æ—Ä—è–¥–æ–∫
        seen = set()
        unique = []
        for item in merged:
            if item not in seen:
                unique.append(item)
                seen.add(item)
        return unique

    # –ò–¥—ë–º –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å –∏–Ω–¥–µ–∫—Å—ã –ø–æ—Å–ª–µ –∑–∞–º–µ–Ω
    for m in reversed(matches):
        key = m.group(1).upper()
        if key == "NICKNAMES":
            pool = merged_nicknames_pool()
        else:
            pool = placeholders.get(key, [])

        if not pool:
            continue

        val = used_values.get(key)
        if val is None:
            val = random.choice(pool)
            used_values[key] = val

        text = text[:m.start()] + val + text[m.end():]

    return text

# --------------------------------------------------------------------------
# 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
# --------------------------------------------------------------------------
def update_user_stats(user_id: int, user_name: str):
    users = load_users()
    stats = load_stats()
    if str(user_id) not in users:
        users[str(user_id)] = {
            "name": user_name,
            "first_seen": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "suggestions_count": 0,
        }
        stats["users_count"] = len(users)
    stats["active_users"].add(str(user_id))
    save_users(users)
    save_stats(stats)


async def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS


# --------------------------------------------------------------------------
# 7. –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ —á–∞—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
# --------------------------------------------------------------------------
async def handle_chat_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if not update.message or update.message.chat.id != COMMENTS_CHAT_ID:
            return
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –∞–≤—Ç–æ‚Äë–ø–µ—Ä–µ—Å–ª–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –∫–∞–Ω–∞–ª–∞
        if not getattr(update.message, "is_automatic_forward", False):
            return

        channel_post_id = None
        # ... existing code ...
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ handle_chat_message: {e}")


async def handle_channel_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.channel_post or update.channel_post.chat.id != CHANNEL_CHAT_ID:
        return
    post_message = update.channel_post
    post_text = post_message.text or post_message.caption or "–ú–µ–¥–∏–∞‚Äë–ø–æ—Å—Ç"
    bot = await context.bot.get_me()
    bot_username = bot.username
    comment_text, reply_markup = generate_bot_comment_buttons(bot_username)

    if "pending_comments" not in context.bot_data:
        context.bot_data["pending_comments"] = {}
    context.bot_data[str(post_message.message_id)] = {
        "text": comment_text,
        "reply_markup": reply_markup,
    }

    add_post_to_history(post_message.message_id, post_text)
    stats = load_stats()
    stats["published"] = stats.get("published", 0) + 1
    save_stats(stats)


def generate_bot_comment_buttons(bot_username: str):
    text = "–ü–æ–ª–µ–∑–Ω—ã–µ –∫–Ω–æ–ø–∫–∏"
    buttons = [
        [
            InlineKeyboardButton(
                "–ü—Ä–µ–¥–ª–æ–∂–∫–∞",
                url=f"https://t.me/{bot_username}?start=suggest",
            )
        ],
        [InlineKeyboardButton("–ù–∞–≤–∏–≥–∞—Ü–∏—è", url="https://t.me/RialEldChron/711")],
        [InlineKeyboardButton("Rampage", url="https://t.me/RialEldChron")],
    ]
    return text, InlineKeyboardMarkup(buttons)


def add_post_to_history(post_id: int, post_text: str):
    posts = load_posts()
    posts[post_id] = {
        "text": post_text[:100] + ("..." if len(post_text) > 100 else ""),
        "date": datetime.now().strftime("%Y-%m-%d %H:%M"),
        "comments": 0,
    }
    save_posts(posts)

# –£–î–ê–õ–Å–ù –¥—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è —Ä–∞–Ω–Ω–∏–π –≤–∞—Ä–∏–∞–Ω—Ç handle_group_message_stats
# –†–∞–Ω—å—à–µ –∑–¥–µ—Å—å –±—ã–ª:
# async def handle_group_message_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
#     ...
# –¢–µ–ø–µ—Ä—å —Å—Ä–∞–∑—É –∏–¥—ë–º –∫ —Å–ª–µ–¥—É—é—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏

def update_suggestion_stats(user_id: int | None = None):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π."""
    stats = load_stats()
    users = load_users()
    today = datetime.now().strftime("%Y-%m-%d")
    if stats.get("today_date") != today:
        stats["today_date"] = today
        stats["today_suggestions"] = 0
    stats["total_suggestions"] += 1
    stats["today_suggestions"] += 1
    if user_id and str(user_id) in users:
        users[str(user_id)]["suggestions_count"] = users[str(user_id)].get("suggestions_count", 0) + 1
    save_stats(stats)
    save_users(users)


async def handle_media(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    if update.message.chat.type != "private":
        return
    user = update.effective_user
    user_id = user.id
    if not context.user_data.get("awaiting_suggestion", False):
        return
    update_suggestion_stats(user_id)
    media_type = "–§–û–¢–û"
    if update.message.video:
        media_type = "–í–ò–î–ï–û"
    elif update.message.document:
        media_type = "–î–û–ö–£–ú–ï–ù–¢"
    report_text = (
        f"üì• –ù–û–í–ê–Ø –ü–†–ï–î–õ–û–ñ–ö–ê (–ú–ï–î–ò–ê)\n"
        f"‚îú‚îÄ –û—Ç: {user.first_name} (@{user.username or '–±–µ–∑ username'})\n"
        f"‚îú‚îÄ ID: {user.id}\n"
        f"‚îî‚îÄ –¢–∏–ø: {media_type}\n"
    )
    try:
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text=report_text,
            message_thread_id=SUGGESTION_TOPIC_ID,
        )
        await update.message.forward(
            chat_id=ADMIN_CHAT_ID,
            message_thread_id=SUGGESTION_TOPIC_ID,
        )
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text="‚îÄ" * 40,
            message_thread_id=SUGGESTION_TOPIC_ID,
        )
        await update.message.reply_text(
            "‚úÖ –ü–æ–ª—É—á–∏–ª! –¢–≤–æ—è –ø—Ä–µ–¥–ª–æ–∂–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –°–ø–∞—Å–∏–±–æ! üí´",
            reply_markup=USER_KEYBOARD,
        )
        context.user_data["awaiting_suggestion"] = False
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_media: {e}")
        await update.message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    if update.message.chat.type != "private":
        return
    user = update.effective_user
    user_id = user.id
    msg_text = (update.message.text or "").strip()

    # –ê–¥–º–∏–Ω‚Äë–∫–Ω–æ–ø–∫–∞ ¬´üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä¬ª
    if msg_text in ("üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä", "üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç–∞—Ç–æ—Ä"):
        if await is_admin(user_id):
            await update.message.reply_text(
                "‚úÖ <b>–î–æ—Å—Ç—É–ø –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!</b>\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è!",
                parse_mode="HTML",
                reply_markup=ADMIN_KEYBOARD,
            )
        else:
            await update.message.reply_text(
                "‚ùå <b>–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω</b>\n–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.",
                parse_mode="HTML",
                reply_markup=USER_KEYBOARD,
            )
        return


    if msg_text == "–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º":
        await update.message.reply_text(
            "üîì <b>–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –≤ –æ–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return

    # –ó–∞–ø—É—Å–∫ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π
    if msg_text == "–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å":
        context.user_data["awaiting_suggestion"] = True
        await update.message.reply_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å–≤–æ—é –Ω–æ–≤–æ—Å—Ç—å! –ö–∞–∂–¥–∞—è —É–Ω–∏–∫–∞–ª—å–Ω–∞—è –∏ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è –Ω–æ–≤–æ—Å—Ç—å –ø–æ–æ—â—Ä—è–µ—Ç—Å—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–º")
        return

    if msg_text == "–ü–æ–º–æ—â—å":
        await update.message.reply_text(
            "‚ÑπÔ∏è <b>–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:</b>\n‚Ä¢ –ù–∞–∂–º–∏—Ç–µ '–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å'\n‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ\n‚Ä¢ –Ø –ø–µ—Ä–µ—à–ª—é –µ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º\nüìå –ö–æ–Ω—Ç–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–º!",
            parse_mode="HTML",
        )
        return


    # –î–æ–ø. –∫–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–æ–≤
    if await is_admin(user_id):
        if msg_text == "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞":
            await show_statistics(update, context)
            return
        elif msg_text == "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏":
            await show_users(update, context)
            return
        elif msg_text == "–ù–∞—Å—Ç—Ä–æ–π–∫–∏":
            await show_settings(update, context)
            return
        elif msg_text == "–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç":
            return await create_post(update, context)

    # –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥ –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–µ–¥–ª–æ–∂–∫–∏
    if context.user_data.get("awaiting_suggestion", False):
        try:
            update_suggestion_stats(user_id)
            report_text = (
                f"üì• –ù–û–í–ê–Ø –ü–†–ï–î–õ–û–ñ–ö–ê\n"
                f"‚îú‚îÄ –û—Ç: {user.first_name} (@{user.username or '–±–µ–∑ username'})\n"
                f"‚îú‚îÄ ID: {user.id}\n"
                f"‚îî‚îÄ –¢–∏–ø: –¢–ï–ö–°–¢\n"
                f"üëá –°–û–î–ï–†–ñ–ò–ú–û–ï:\n{msg_text}\n"
            )
            await context.bot.send_message(
                chat_id=ADMIN_CHAT_ID,
                text=report_text,
                message_thread_id=SUGGESTION_TOPIC_ID,
            )
            await context.bot.send_message(
                chat_id=ADMIN_CHAT_ID,
                text="‚îÄ" * 40,
                message_thread_id=SUGGESTION_TOPIC_ID,
            )
            await update.message.reply_text(
                "‚úÖ –ü–æ–ª—É—á–∏–ª! –¢–≤–æ—è –ø—Ä–µ–¥–ª–æ–∂–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –°–ø–∞—Å–∏–±–æ! –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã –æ—Ç–ø—Ä–∞–≤—è—Ç —Ç–µ–±–µ –ø—Ä–æ–º–æ–∫–æ–¥ –≤ –ª–∏—á–∫—É!",
                reply_markup=USER_KEYBOARD,
            )
            context.user_data["awaiting_suggestion"] = False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_message: {e}")
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return


# --------------------------------------------------------------------------
# 10. –°—Ç–∞—Ä—Ç –∏ –æ—Ç–ª–∞–¥–∫–∞
# --------------------------------------------------------------------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    if update.message.chat.type != "private":
        return
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    update_user_stats(user_id, user_name)
    welcome_text = f"–ü—Ä–∏–≤–µ—Ç, {user_name}! üëã\n–Ø –ú–∞–ª–µ–Ω—å–∫–∏–π —Ö—Ä–æ–Ω–∏—Å—Ç, —Å–æ–±–∏—Ä–∞—é –ø—Ä–µ–¥–ª–æ–∂–∫—É –∏ –Ω–µ —Ç–æ–ª—å–∫–æ. –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:"
    await update.message.reply_text(welcome_text, reply_markup=USER_KEYBOARD)


async def debug_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not await is_admin(update.effective_user.id):
        return
    mirror_map = load_mirror_map()
    debug_text = (
        "üìä <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏:</b>\n"
        f"üîß ID –∫–∞–Ω–∞–ª–∞: <code>{CHANNEL_CHAT_ID}</code>\n"
        f"üîß ID —á–∞—Ç–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤: <code>{COMMENTS_CHAT_ID}</code>\n"
        f"üîß ID –≥—Ä—É–ø–ø—ã –ø—Ä–µ–¥–ª–æ–∂–µ–∫: <code>{GROUP_CHAT_ID}</code>\n"
        f"üîß Username –∫–∞–Ω–∞–ª–∞: @{CHANNEL_USERNAME}\n"
        f"üîó –°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Å–≤—è–∑–∫–∏ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 5):\n"
    )
    for k, v in list(mirror_map.items())[-5:]:
        debug_text += f"\n‚Ä¢ –ö–∞–Ω–∞–ª {k} ‚Üí –ß–∞—Ç {v}"
    if not mirror_map:
        debug_text += "\n–ü–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —Å–≤—è–∑–æ–∫"
    await update.message.reply_text(debug_text, parse_mode="HTML")
    return

async def chat_id_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    await update.message.reply_text(f"chat.id = {chat.id}")

async def show_statistics(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not await is_admin(update.effective_user.id):
        return
    users = load_users()
    cutoff = (datetime.now() - timedelta(days=6)).strftime("%Y-%m-%d")
    ranking = []
    for uid, u in users.items():
        msg_counts = u.get("msg_counts", {})
        total7 = sum(int(cnt) for day, cnt in msg_counts.items() if day >= cutoff)
        if total7 > 0:
            ranking.append((total7, int(uid), u.get("name") or uid))
    ranking.sort(reverse=True, key=lambda x: x[0])
    if not ranking:
        await update.message.reply_text("–ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ.")
        return
    lines = ["–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —á–∞—Ç–∞ –∑–∞ 7 –¥–Ω–µ–π (—á–∞—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤):"]
    for idx, (cnt, uid, name) in enumerate(ranking, start=1):
        lines.append(f"{idx}. {name} (id {uid}): {cnt}")
    await update.message.reply_text("\n".join(lines[:100]))


async def show_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üë• –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")


async def show_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")


# --------------------------------------------------------------------------
# 11. –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–∞
# --------------------------------------------------------------------------
async def create_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not await is_admin(update.effective_user.id):
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å—Ç–æ–≤.")
        return ConversationHandler.END
    await update.message.reply_text("üìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞:")
    return GET_TEXT


async def get_post_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["post_text"] = update.message.text
    await update.message.reply_text(
        "üìé –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–Ω–æ–ø–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "`–ö–Ω–æ–ø–∫–∞ 1 - https://example.com`\n"
        "–ö–∞–∂–¥–∞—è –∫–Ω–æ–ø–∫–∞ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.\n"
        "–ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ '–ë–µ–∑ –∫–Ω–æ–ø–æ–∫'.",
        parse_mode="HTML",
    )
    return GET_BUTTONS


async def process_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = context.user_data.get("post_text", "–¢–µ–∫—Å—Ç –Ω–µ –∑–∞–¥–∞–Ω")
    buttons_text = update.message.text
    reply_markup = None
    if buttons_text.strip().lower() != "–±–µ–∑ –∫–Ω–æ–ø–æ–∫":
        try:
            button_rows = []
            for line in buttons_text.split("\n"):
                if " - " in line:
                    label, url = line.split(" - ", 1)
                    button_rows.append(
                        [InlineKeyboardButton(label.strip(), url=url.strip())]
                    )
            if button_rows:
                reply_markup = InlineKeyboardMarkup(button_rows)
        except Exception:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∫–Ω–æ–ø–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return GET_BUTTONS
    try:
        sent = await context.bot.send_message(
            chat_id=CHANNEL_CHAT_ID,
            text=text,
            reply_markup=reply_markup,
            disable_web_page_preview=False,
        )
        add_post_to_history(sent.message_id, text)
        await update.message.reply_text("‚úÖ –ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –≤ –∫–∞–Ω–∞–ª–µ!")
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {str(e)}")
    return ConversationHandler.END


async def cancel_creation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    return ConversationHandler.END


# --------------------------------------------------------------------------
# 12. –õ–∞–±–∏—Ä–∏–Ω—Ç ‚Äì –ª–æ–≥–∏–∫–∞ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
# --------------------------------------------------------------------------
class LabyrinthState:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.hp = LABYRINTH_START_HP
        self.step = 0
        self.messages = []  # message_id, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å
        self.last_labyrinth = None  # YYYY‚ÄëMM‚ÄëDD
        self.wins = 0
        self.loses = 0


def load_laby_state(uid: int) -> LabyrinthState:
    users = load_users()
    u = users.get(str(uid), {})
    state = LabyrinthState(uid)
    state.hp = u.get("labyrinth_hp", LABYRINTH_START_HP)
    state.step = u.get("labyrinth_step", 0)
    state.last_labyrinth = u.get("last_labyrinth")
    state.wins = u.get("labyrinth_wins", 0)
    state.loses = u.get("labyrinth_loses", 0)
    return state


def save_laby_state(state: LabyrinthState):
    users = load_users()
    u = users.get(str(state.user_id), {})
    u.update(
        {
            "labyrinth_hp": state.hp,
            "labyrinth_step": state.step,
            "last_labyrinth": state.last_labyrinth,
            "labyrinth_wins": state.wins,
            "labyrinth_loses": state.loses,
        }
    )
    users[str(state.user_id)] = u
    save_users(users)


# --------------------------------------------------------------------------
# 13. Helper –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∑–∞–ø–∏—Å–∏ ID
# --------------------------------------------------------------------------
async def send_and_record(update: Update, context: ContextTypes.DEFAULT_TYPE,
                          state: LabyrinthState, text: str,
                          image: str | None = None,
                          reply_markup=None, parse_mode="HTML"):
    msg_id = await send_message_with_cleanup(
        update, context, text, image, reply_markup, parse_mode
    )
    if state:
        state.messages.append(msg_id)
    return msg_id


# --------------------------------------------------------------------------
# 14. –§—É–Ω–∫—Ü–∏–∏ –ø—Ä–∞–≤–∏–ª –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
# --------------------------------------------------------------------------
async def start_labyrinth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    state = load_laby_state(user_id)

    today = datetime.now().strftime("%Y-%m-%d")
    if LABYRINTH_DAILY_LIMIT_ENABLED and state.last_labyrinth == today:
        await update.message.reply_text("–í—ã —É–∂–µ –∏–≥—Ä–∞–ª–∏ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–¥–æ–∂–¥–∏, –ø–æ–∫–∞ —Å–º–µ–Ω–∏—Ç—Å—è –¥–µ–Ω—å.")
        return ConversationHandler.END

    # Reset state
    state.hp = LABYRINTH_START_HP
    state.step = 0
    state.last_labyrinth = today
    state.messages = []
    save_laby_state(state)

    msgs = load_messages()
    greet = msgs["greetings"][0]
    if state.wins + state.loses == 0:
        greet_text, greet_img = greet["first_time"]["text"], greet["first_time"]["image"]
    else:
        greet_text, greet_img = greet["subsequent"]["text"], greet["subsequent"]["image"]

    greet_text = f"üí™ HP: {state.hp}\n{resolve_placeholders(greet_text, msgs['placeholders'])}"
    markup = ReplyKeyboardMarkup(
        [["–•–æ—á—É –≥–æ–ª–¥—É"], ["–ù–µ —Ö–æ—á—É –≥–æ–ª–¥—É"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
    )
    await send_and_record(update, context, state, greet_text, greet_img, markup)
    return LABYRINTH_GAME


async def labyrinth_handle_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    state = load_laby_state(user.id)
    msgs = load_messages()
    choice = (update.message.text or "").strip()

    # 1. –í—ã—Ö–æ–¥ –≤ –º–µ–Ω—é
    if choice == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        for msg_id in state.messages:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
            except Exception:
                pass
        state.messages = []
        save_laby_state(state)
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return ConversationHandler.END

    # 1.1 –ü—Å–µ–≤–¥–æ‚Äë–ø—Ä–æ–º–æ‚Äë–∫–Ω–æ–ø–∫–∏ –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –∏–≥—Ä—ã ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
    if choice in ("–•–æ—á—É –≥–æ–ª–¥—É", "–ù–µ —Ö–æ—á—É –≥–æ–ª–¥—É"):
        ended = await handle_event(update, context, state, msgs, skip_special=True)
        save_laby_state(state)
        return ConversationHandler.END if ended else LABYRINTH_GAME

    # 2. –°–ø–µ—Ü-–≤–µ—Ç–∫–∞ (–ø–æ—Å–ª–µ special-—Å–æ–±—ã—Ç–∏—è)
    if choice == "–ü—Ä–æ–π—Ç–∏ –º–∏–º–æ":
        ended = await handle_event(update, context, state, msgs, skip_special=True)
        save_laby_state(state)
        return ConversationHandler.END if ended else LABYRINTH_GAME

    if choice == "–°–º–µ—Ä—Ç—å":
        state.loses += 1
        state.hp = 0
        await send_defeat(update, context, state, reason="special_death")
        for msg_id in state.messages:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
            except Exception:
                pass
        state.messages = []
        save_laby_state(state)
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return ConversationHandler.END

    # 3. –î–≤–∏–∂–µ–Ω–∏—è
    if choice in ("–ù–∞–ª–µ–≤–æ", "–í–ø–µ—Ä–µ–¥", "–ù–∞–ø—Ä–∞–≤–æ"):
        state.step += 1
        if state.step >= LABYRINTH_MAX_STEPS:
            await send_victory(update, context, state, msgs)
            state.wins += 1
            for msg_id in state.messages:
                try:
                    await context.bot.delete_message(
                        chat_id=update.effective_chat.id, message_id=msg_id
                    )
                except Exception:
                    pass
            state.messages = []
            save_laby_state(state)
            await update.message.reply_text(
                "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
            )
            return ConversationHandler.END

        ended = await handle_event(update, context, state, msgs)
        save_laby_state(state)
        return ConversationHandler.END if ended else LABYRINTH_GAME

    return LABYRINTH_GAME

async def handle_event(update: Update, context: ContextTypes.DEFAULT_TYPE,
                      state: LabyrinthState, msgs: dict,
                      skip_special: bool = False):
    probs = {
        1: 0.20,
        2: 0.09,
        3: 0.11,
        4: 0.2475,
        5: 0.1925,
        6: 0.11,
    }
    if not skip_special:
        probs[7] = 0.05
    items, weights = zip(*probs.items())
    sel = random.choices(items, weights=weights)[0]

    if sel == 7:  # Special
        tmpl = random.choice(msgs["events"]["special"])
        text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
        msg_text = f"{text}\nüí™ HP: {state.hp}"
        markup = ReplyKeyboardMarkup(
            [["–ü—Ä–æ–π—Ç–∏ –º–∏–º–æ"], ["–°–º–µ—Ä—Ç—å"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]],
            one_time_keyboard=True
        )
        await send_and_record(update, context, state, msg_text, tmpl["image"], markup)
        return   # –¥–∏–∞–ª–æ–≥ –Ω–µ –∑–∞–≤–µ—Ä—à—ë–Ω

    events = msgs["events"][str(sel)]
    tmpl = random.choice(events)
    delta = 0
    effect = None
    if sel == 2:
        delta = 2
        effect = "(+2 HP)"
    elif sel == 3:
        delta = 1
        effect = "(+1 HP)"
    elif sel == 4:
        delta = -1
        effect = "(-1 HP)"
    elif sel == 5:
        delta = -2
        effect = "(-2 HP)"
    elif sel == 6:
        delta = -3
        effect = "(-3 HP)"
    state.hp += delta

    if state.hp <= 0:
        state.loses += 1
        state.hp = 0
        await send_defeat(update, context, state, reason="hp_zero")
        # –æ—á–∏—Å—Ç–∫–∞ –∏ –≤—ã—Ö–æ–¥ –≤ –º–µ–Ω—é
        for msg_id in state.messages:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=msg_id)
            except Exception:
                pass
        state.messages = []
        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å HP=0
        save_laby_state(state)
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return True  # –¥–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à—ë–Ω

    text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
    msg_text = f"{text}\nüí™ HP: {state.hp}\n{effect if effect else ''}"
    markup = ReplyKeyboardMarkup(
        [["–ù–∞–ª–µ–≤–æ"], ["–í–ø–µ—Ä–µ–¥"], ["–ù–∞–ø—Ä–∞–≤–æ"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
    )
    await send_and_record(update, context, state, msg_text, tmpl["image"], markup)
    return False  # –¥–∏–∞–ª–æ–≥ –Ω–µ –∑–∞–≤–µ—Ä—à—ë–Ω

async def send_defeat(update: Update, context: ContextTypes.DEFAULT_TYPE,
                     state: LabyrinthState, reason: str):
    msgs = load_messages()
    if reason == "not_desire":
        tmpl = random.choice(msgs["defeat1"])
    elif reason == "special_death":
        tmpl = random.choice(msgs["defeat2"])
    else:
        tmpl = random.choice(msgs["defeat"])
    text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
    msg_text = f"{text}\n‚ö†Ô∏è HP: {state.hp}"
    await send_and_record(update, context, state, msg_text, tmpl["image"])


async def send_victory(update: Update, context: ContextTypes.DEFAULT_TYPE,
                       state: LabyrinthState, msgs: dict):
    tmpl = random.choice(msgs["victory"])
    text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
    msg_text = f"{text}\nüèÜ HP: {state.hp}"
    await send_and_record(update, context, state, msg_text, tmpl["image"])
    promo = get_daily_promo()
    if promo:
        await update.message.reply_text(
            f"üéÅ –¢–≤–æ–π –ø—Ä–æ–º–æ–∫–æ–¥: <code>{promo}</code>", parse_mode="HTML"
        )
    else:
        await update.message.reply_text(
            "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–º–æ–∫–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å, –Ω–æ –≤—ã –≤—Å–µ —Ä–∞–≤–Ω–æ –º–æ–ª–æ–¥–µ—Ü!"
        )

def get_daily_promo() -> str | None:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–∏–Ω –ø—Ä–æ–º–æ–∫–æ–¥ –Ω–∞ –¥–µ–Ω—å, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ."""
    stats = load_json(PROMO_STATS_FILE, {})
    today = datetime.now().strftime("%Y-%m-%d")
    if stats.get("last_date") != today:
        stats["last_date"] = today
        stats["count"] = 0
    if stats.get("count", 0) >= LABYRINTH_PROMO_LIMIT_PER_DAY:
        save_json(PROMO_STATS_FILE, stats)
        return None
    if not os.path.exists(PROMOS_FILE):
        return None
    with open(PROMOS_FILE, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f if l.strip()]
    if not lines:
        return None
    promo = lines.pop(0)
    with open(PROMOS_FILE, "w", encoding="utf-8") as f:
        f.writelines(l + "\n" for l in lines)
    stats["count"] = stats.get("count", 0) + 1
    save_json(PROMO_STATS_FILE, stats)
    return promo

def get_comment_promo() -> str | None:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π –ø—Ä–æ–º–æ–∫–æ–¥ –∏–∑ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ø—É–ª–∞ –¥–ª—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ (comment_promos.txt).
    –ù–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∏–≥—Ä–æ–≤—ã—Ö –ª–∏–º–∏—Ç–æ–≤.
    """
    if not os.path.exists(COMMENT_PROMOS_FILE):
        return None
    with open(COMMENT_PROMOS_FILE, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f if l.strip()]
    if not lines:
        return None
    promo = lines.pop(0)
    with open(COMMENT_PROMOS_FILE, "w", encoding="utf-8") as f:
        f.writelines(l + "\n" for l in lines)
    return promo


# --------------------------------------------------------------------------
# 15. –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
# --------------------------------------------------------------------------
async def send_message_with_cleanup(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                   text: str,
                                   image: str | None = None,
                                   reply_markup=None,
                                   parse_mode="HTML"):
    chat_id = update.effective_chat.id
    if image and os.path.exists(os.path.join("images", image)):
        with open(os.path.join("images", image), "rb") as f:
            sent = await context.bot.send_photo(
                chat_id=chat_id,
                photo=f,
                caption=text,
                parse_mode=parse_mode,
                reply_markup=reply_markup,
            )
    else:
        sent = await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            parse_mode=parse_mode,
            reply_markup=reply_markup,
        )
    asyncio.create_task(schedule_delete(context, chat_id, sent.message_id))
    return sent.message_id


async def schedule_delete(context: ContextTypes.DEFAULT_TYPE, chat_id: int, msg_id: int):
    await asyncio.sleep(120)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
    except Exception:
        pass


# --------------------------------------------------------------------------
# 16. –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
# --------------------------------------------------------------------------
async def main():
    # –°–æ–∑–¥–∞—ë–º –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
    for path, default in [
        (STATS_FILE, load_stats()),
        (USERS_FILE, {}),
        (POSTS_FILE, {}),
        (MIRROR_MAP_FILE, {}),
    ]:
        if not os.path.exists(path):
            if isinstance(default, set):
                default = list(default)
            with open(path, "w", encoding="utf-8") as f:
                json.dump(default, f, ensure_ascii=False, indent=2)
    if not os.path.exists("images"):
        os.makedirs("images")
        print("üìÅ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ 'images'")

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è promo_stats –ø–æ–¥ ¬´—á–∞—Ç–æ–≤—ã–µ¬ª –ø–æ–ª—è (—á—Ç–æ–±—ã —Ñ–∞–π–ª —Ç–æ—á–Ω–æ –∏–º –∏—Ö —Å–æ–¥–µ—Ä–∂–∞–ª)
    today = datetime.now().strftime("%Y-%m-%d")
    stats = load_json(PROMO_STATS_FILE, {})
    if stats.get("chat_last_date") != today:
        stats["chat_last_date"] = today
        stats["chat_comments_count"] = 0
        stats["chat_dropped_today"] = False
        save_json(PROMO_STATS_FILE, stats)

    app = Application.builder().token(BOT_TOKEN).build()


    # ===== –†–∞–∑–≥–æ–≤–æ—Ä—ã: –æ–±—ä—è–≤–ª—è–µ–º –ü–ï–†–ï–î —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–µ–π =====
    labyrinth_conv = ConversationHandler(
        entry_points=[
            MessageHandler(
                filters.Regex(re.compile(r"^\s*(–∏–≥—Ä–∞—Ç—å –≤\s+(?:–ª–∞–±–∏—Ä–∏–Ω—Ç|–ø–æ–∂–∏–ª–æ–π —Ç—Ä–∏–ø))\s*$", re.IGNORECASE)),
                show_rules,
            )
        ],
        states={
            LABYRINTH_START: [MessageHandler(filters.TEXT & ~filters.COMMAND, wait_start)],
            LABYRINTH_GAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, labyrinth_handle_choice)],
        },
        fallbacks=[],
        allow_reentry=True,
    )

    post_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(r"^–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç$"), create_post)],
        states={
            GET_TEXT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_post_text)],
            GET_BUTTONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_buttons)],
        },
        fallbacks=[MessageHandler(filters.Regex(r"^–û—Ç–º–µ–Ω–∏—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ$"), cancel_creation)],
        allow_reentry=True,
    )

    # ===== –•–µ–Ω–¥–ª–µ—Ä—ã –¥–ª—è –∫–∞–Ω–∞–ª–∞/–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ =====
    # –ó–µ—Ä–∫–∞–ª–æ: –æ–±—ã—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –±–µ–∑ –∫–æ–º–∞–Ω–¥/—Å—Ç–∞—Ç—É—Å–æ–≤ (–∞–≤—Ç–æ—Ñ–æ—Ä–≤–∞—Ä–¥ –æ—Ç—Ñ–∏–ª—å—Ç—Ä—É–µ—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞)
    app.add_handler(
        MessageHandler(
            filters.Chat(COMMENTS_CHAT_ID) & ~filters.COMMAND & ~filters.StatusUpdate.ALL,
            handle_chat_message
        ),
        group=0
    )

    # –ü–æ—Å—Ç—ã –∫–∞–Ω–∞–ª–∞
    app.add_handler(
        MessageHandler(filters.ChatType.CHANNEL, handle_channel_post),
        group=0
    )

    # –°—á—ë—Ç—á–∏–∫/–¥—Ä–æ–ø: –ª—é–±—ã–µ –æ–±—ã—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–Ω–µ —Å—Ç–∞—Ç—É—Å—ã); –∞–≤—Ç–æ—Ñ–æ—Ä–≤–∞—Ä–¥ –∏—Å–∫–ª—é—á–∏–º –≤–Ω—É—Ç—Ä–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
    app.add_handler(
        MessageHandler(
            filters.Chat(COMMENTS_CHAT_ID) & ~filters.StatusUpdate.ALL,
            handle_group_message_stats
        ),
        group=1
    )

    # –†–∞–∑–≥–æ–≤–æ—Ä—ã ‚Äî –¥–æ –æ–±—â–µ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ
    app.add_handler(labyrinth_conv, group=0)
    app.add_handler(post_conv, group=0)

    # –ö–æ–º–∞–Ω–¥—ã
    app.add_handler(CommandHandler("start", start), group=0)
    app.add_handler(CommandHandler("debug", debug_info), group=0)
    app.add_handler(CommandHandler("promo_chat_debug", promo_chat_debug), group=0)
    app.add_handler(CommandHandler("chat_id", chat_id_cmd), group=0)

    # –û–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message), group=0)

    # --- –ó–∞–ø—É—Å–∫ ---
    await app.initialize()
    await app.start()
    await app.updater.initialize()
    await app.updater.start_polling()
    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")

    try:
        await asyncio.Future()  # run forever
    except asyncio.CancelledError:
        pass
    finally:
        try:
            await app.updater.stop()
        except Exception:
            pass
        await app.stop()
        await app.shutdown()


if __name__ == "__main__":
    asyncio.run(main())
