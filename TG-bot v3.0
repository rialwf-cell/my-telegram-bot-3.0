#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
–ë–æ—Ç‚Äë—Å–µ—Ä–≤–∏—Å ¬´–ö–∞–Ω–∞–ª + –ü—Ä–µ–¥–ª–æ–∂–∫–∏ + –õ–∞–±–∏—Ä–∏–Ω—Ç¬ª
(Python‚Äëtelegram‚Äëbot v20.7+, Python‚ÄØ3.10+)

*   –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–±–µ–¥/–ø–æ—Ä–∞–∂–µ–Ω–∏–π –≤ —Å–æ–æ–±—â–µ–Ω–∏—è—Ö –∏–≥—Ä–æ–∫–∞
*   –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä ¬´NICKNAMES¬ª —Ç–µ–ø–µ—Ä—å –ø–æ–¥–º–µ–Ω—è–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º.
"""

# --------------------------------------------------
# 1. –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
# --------------------------------------------------
import os
import json
import re
import asyncio
import random
import logging

from datetime import datetime, timedelta
from collections import defaultdict

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ReplyKeyboardMarkup,
)
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    ConversationHandler,
    filters,
)

# --------------------------------------------------
# 2. –ù–∞—Å—Ç—Ä–æ–π–∫–∏
# --------------------------------------------------
BOT_TOKEN = "***************"   # ‚Üê –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ç–æ–∫–µ–Ω —Å–≤–æ–µ–≥–æ –±–æ—Ç–∞

ADMIN_IDS = [**********]              # ‚Üê ID(—ã) –∞–¥–º–∏–Ω–æ–≤
CHANNEL_USERNAME = "**********"  # ‚Üê username –∫–∞–Ω–∞–ª–∞ –±–µ–∑ @
CHANNEL_CHAT_ID = -100************     # ‚Üê ID –∫–∞–Ω–∞–ª–∞
GROUP_CHAT_ID = -100***********       # ‚Üê ID –≥—Ä—É–ø–ø—ã –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–∫
SUGGESTION_TOPIC_ID = ****           # ‚Üê ID —Ç–µ–º—ã –≤ –≥—Ä—É–ø–ø–µ
ADMIN_CHAT_ID = GROUP_CHAT_ID
COMMENTS_CHAT_ID = -100***********    # ‚Üê —á–∞—Ç —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏

# –§–∞–π–ª—ã
STATS_FILE = "bot_stats.json"
USERS_FILE = "bot_users.json"
POSTS_FILE = "bot_posts.json"
MIRROR_MAP_FILE = "mirror_map.json"
PROMOS_FILE = "promos.txt"
PROMO_STATS_FILE = "promo_stats.json"

# –õ–∞–±–∏—Ä–∏–Ω—Ç
LABYRINTH_MAX_STEPS = 10
LABYRINTH_START_HP = 10
LABYRINTH_DAILY_LIMIT_ENABLED = False  # –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ 1‚Äë—Ä–∞–∑‚Äë–≤‚Äë—Å—É—Ç–∫–∏
LABYRINTH_PROMO_LIMIT_PER_DAY = 5

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
ADMIN_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"],
        ["–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏"],
        ["–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º"],
    ],
    resize_keyboard=True,
)

USER_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å", "–ò–≥—Ä–∞—Ç—å –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç"],
        ["–ü–æ–º–æ—â—å", "üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç–∞—Ç–æ—Ä"],
    ],
    resize_keyboard=True,
)

# –°–æ—Å—Ç–æ—è–Ω–∏—è ConversationHandler
GET_TEXT, GET_BUTTONS, LABYRINTH_GAME = range(3)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# 2.–õ–û–ì–ò–†–û–í–ê–ù–ò–ï
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# --------------------------------------------------
# 4. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
# --------------------------------------------------
def load_json(path: str, default):
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.warning(f"Error reading {path}: {e}")
    return default


def save_json(path: str, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def load_stats():
    data = load_json(
        STATS_FILE,
        {
            "total_suggestions": 0,
            "published": 0,
            "rejected": 0,
            "today_suggestions": 0,
            "today_date": datetime.now().strftime("%Y-%m-%d"),
            "users_count": 0,
            "active_users": set(),
        },
    )
    if isinstance(data.get("active_users", []), list):
        data["active_users"] = set(data["active_users"])
    return data


def save_stats(stats):
    s = stats.copy()
    s["active_users"] = list(s["active_users"])
    save_json(STATS_FILE, s)


def load_users():
    return load_json(USERS_FILE, {})


def save_users(users):
    save_json(USERS_FILE, users)


def load_posts():
    return load_json(POSTS_FILE, {})


def save_posts(posts):
    save_json(POSTS_FILE, posts)


def load_mirror_map():
    return load_json(MIRROR_MAP_FILE, {})


def save_mirror_map(m):
    save_json(MIRROR_MAP_FILE, m)


def get_daily_promo() -> str | None:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–∏–Ω –ø—Ä–æ–º–æ–∫–æ–¥ –Ω–∞ –¥–µ–Ω—å, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ."""
    stats = load_json(PROMO_STATS_FILE, {})
    today = datetime.now().strftime("%Y-%m-%d")
    if stats.get("last_date") != today:
        stats["last_date"] = today
        stats["count"] = 0
    if stats.get("count", 0) >= LABYRINTH_PROMO_LIMIT_PER_DAY:
        save_json(PROMO_STATS_FILE, stats)
        return None
    if not os.path.exists(PROMOS_FILE):
        return None
    with open(PROMOS_FILE, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f if l.strip()]
    if not lines:
        return None
    promo = lines.pop(0)
    with open(PROMOS_FILE, "w", encoding="utf-8") as f:
        f.writelines(l + "\n" for l in lines)
    stats["count"] = stats.get("count", 0) + 1
    save_json(PROMO_STATS_FILE, stats)
    return promo


# --------------------------------------------------
# 5. –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã –∏ —Å–æ–æ–±—â–µ–Ω–∏—è
# --------------------------------------------------
def load_messages() -> dict:
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ `messages.json`.
    –ï—Å–ª–∏ —Ñ–∞–π–ª/–ø–∞–ø–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç ‚Äì —Å–æ–∑–¥–∞—ë—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ ¬´–∑–∞–≥–ª—É—à–∫–∏¬ª,
    —á—Ç–æ–±—ã `random.choice()` –Ω–µ –ø–∞–¥–∞–ª —Å `IndexError`. """
    msgs = load_json("messages.json", {})

    # ---------- –ì—Ä–µ–π—Ç–∏–Ω–≥–∏ ----------
    if "greetings" not in msgs or not msgs["greetings"]:
        msgs["greetings"] = [
            {
                "first_time": {"text": "–ü—Ä–∏–≤–µ—Ç, NICKNAMES! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç.", "image": ""},
                "subsequent": {"text": "–¢—ã —É–∂–µ –∑–¥–µ—Å—å, NICKNAMES.", "image": ""},
            }
        ]

    # ---------- –ü–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã ----------
    if "placeholders" not in msgs:
        msgs["placeholders"] = {
            "NICKNAMES": ["Alex", "Masha", "Ivan"],
            "NICK_WB": ["–ë–æ—Ä–∏—Å", "–ö–∏—Ä–∏–ª–ª"],
            "NICK_EP": ["–≠–ª—å—Ñ", "–ì–Ω–æ–º"],
            "NICK_WINX": ["–í–æ–∏–Ω", "–ì–µ—Ä–æ–π"],
        }

    # ---------- –°–æ–±—ã—Ç–∏—è 1‚Äë6 + special ----------
    if "events" not in msgs:
        msgs["events"] = {}
    for key in ("1", "2", "3", "4", "5", "6", "special"):
        if key not in msgs["events"]:
            msgs["events"][key] = []

        if not msgs["events"][key]:
            msgs["events"][key] = [
                {"text": f"–ü–æ–∫–∞–∂–µ–Ω–æ —Å–æ–±—ã—Ç–∏–µ {key} (–∑–∞–≥–ª—É—à–∫–∞).", "image": ""}
            ]

    # ---------- –ü–æ—Ä–∞–∂–µ–Ω–∏—è / –ø–æ–±–µ–¥—ã ----------
    for key in ("defeat1", "defeat2", "defeat", "victory"):
        if key not in msgs:
            msgs[key] = []

        if not msgs[key]:
            msgs[key] = [
                {"text": f"–ó–∞–≥–ª—É—à–∫–∞ {key}.", "image": ""},
            ]

    return msgs


# –†–µ–≥—É–ª—è—Ä–∫–∞ –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤ (—Ä–µ–≥–∏—Å—Ç—Ä –±–µ–∑ —Ä–∞–∑–Ω–∏—Ü—ã)
PMS_RE = re.compile(r"\b(NICK_(?:WB|EP|WINX|NAMES)|NICKNAMES)\b", re.IGNORECASE)


def resolve_placeholders(text: str, placeholders: dict) -> str:
    """–ü–æ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –≤ —Å—Ç—Ä–æ–∫—É —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–≤."""
    matches = list(PMS_RE.finditer(text))
    if not matches:
        return text
    used_values = {}
    for m in matches:
        key = m.group(1).upper()
        pool = placeholders.get(key, [])
        if not pool:
            continue
        val = used_values.get(key)
        if val is None:
            val = random.choice(pool)
            used_values[key] = val
        text = text[:m.start()] + val + text[m.end():]
    return text


# --------------------------------------------------------------------------
# 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
# --------------------------------------------------------------------------
def update_user_stats(user_id: int, user_name: str):
    users = load_users()
    stats = load_stats()
    if str(user_id) not in users:
        users[str(user_id)] = {
            "name": user_name,
            "first_seen": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "suggestions_count": 0,
        }
        stats["users_count"] = len(users)
    stats["active_users"].add(str(user_id))
    save_users(users)
    save_stats(stats)


async def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS


# --------------------------------------------------------------------------
# 7. –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ —á–∞—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
# --------------------------------------------------------------------------
async def handle_chat_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if not update.message or update.message.chat.id != COMMENTS_CHAT_ID:
            return
        if not getattr(update.message, "is_automatic_forward", False):
            return

        channel_post_id = None
        if hasattr(update.message, "forward_origin") and update.message.forward_origin:
            origin = update.message.forward_origin
            if hasattr(origin, "chat") and origin.chat and origin.chat.id == CHANNEL_CHAT_ID:
                if hasattr(origin, "message_id"):
                    channel_post_id = origin.message_id

        if not channel_post_id:
            channel_post_id = getattr(update.message, "forward_from_message_id", None)

        chat_message_id = update.message.message_id
        if not channel_post_id:
            logger.warning(
                f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ID –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ø–æ—Å—Ç–∞ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è {chat_message_id}"
            )
            return

        mirror_map = load_mirror_map()
        mirror_map[str(channel_post_id)] = chat_message_id
        save_mirror_map(mirror_map)
        logger.info(
            f"üîó –°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ —Å–≤—è–∑–∫–∞: –ø–æ—Å—Ç –≤ –∫–∞–Ω–∞–ª–µ {channel_post_id} ‚Üí —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ {chat_message_id}"
        )

        pending_comments = context.bot_data.get("pending_comments", {})
        key = str(channel_post_id)
        if key in pending_comments:
            data = pending_comments[key]
            comment_text = data["text"]
            reply_markup = data["reply_markup"]
            try:
                await context.bot.send_message(
                    chat_id=COMMENTS_CHAT_ID,
                    text=comment_text,
                    reply_markup=reply_markup,
                    parse_mode="HTML",
                    reply_to_message_id=chat_message_id,
                )
                logger.info(f"‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –∑–µ—Ä–∫–∞–ª–æ {chat_message_id}")
                del pending_comments[key]
                context.bot_data["pending_comments"] = pending_comments
            except Exception as e:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {e}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ handle_chat_message: {e}")


async def handle_channel_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.channel_post or update.channel_post.chat.id != CHANNEL_CHAT_ID:
        return
    post_message = update.channel_post
    post_text = post_message.text or post_message.caption or "–ú–µ–¥–∏–∞‚Äë–ø–æ—Å—Ç"
    bot = await context.bot.get_me()
    bot_username = bot.username
    comment_text, reply_markup = generate_bot_comment_buttons(bot_username)

    if "pending_comments" not in context.bot_data:
        context.bot_data["pending_comments"] = {}
    context.bot_data[str(post_message.message_id)] = {
        "text": comment_text,
        "reply_markup": reply_markup,
    }

    add_post_to_history(post_message.message_id, post_text)
    stats = load_stats()
    stats["published"] = stats.get("published", 0) + 1
    save_stats(stats)


def generate_bot_comment_buttons(bot_username: str):
    text = "–ü–æ–ª–µ–∑–Ω—ã–µ –∫–Ω–æ–ø–∫–∏"
    buttons = [
        [
            InlineKeyboardButton(
                "–ü—Ä–µ–¥–ª–æ–∂–∫–∞",
                url=f"https://t.me/{bot_username}?start=suggest",
            )
        ],
        [InlineKeyboardButton("–ù–∞–≤–∏–≥–∞—Ü–∏—è", url="https://t.me/RialEldChron/711")],
        [InlineKeyboardButton("Rampage", url="https://t.me/RialEldChron")],
    ]
    return text, InlineKeyboardMarkup(buttons)


def add_post_to_history(post_id: int, post_text: str):
    posts = load_posts()
    posts[post_id] = {
        "text": post_text[:100] + ("..." if len(post_text) > 100 else ""),
        "date": datetime.now().strftime("%Y-%m-%d %H:%M"),
        "comments": 0,
    }
    save_posts(posts)


# --------------------------------------------------------------------------
# 8. –°—á—ë—Ç—á–∏–∫ —á–∞—Ç–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
# --------------------------------------------------------------------------
async def handle_group_message_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        if not update.message or update.message.chat.id != COMMENTS_CHAT_ID:
            return
        user = update.effective_user
        if not user:
            return

        users = load_users()
        u = users.setdefault(str(user.id), {
            "name": user.first_name,
            "first_seen": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "suggestions_count": 0,
        })
        u["name"] = u.get("name") or user.first_name
        today = datetime.now().strftime("%Y-%m-%d")
        msg_counts = u.setdefault("msg_counts", {})
        msg_counts[today] = msg_counts.get(today, 0) + 1
        save_users(users)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_group_message_stats: {e}")


# --------------------------------------------------------------------------
# 9. –ü–æ–¥–ø–∏—Å—å –∏ –ø—Ä–µ–¥–ª–æ–∂–∫–∏
# --------------------------------------------------------------------------
def update_suggestion_stats(user_id: int | None = None):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π."""
    stats = load_stats()
    users = load_users()
    today = datetime.now().strftime("%Y-%m-%d")
    if stats.get("today_date") != today:
        stats["today_date"] = today
        stats["today_suggestions"] = 0
    stats["total_suggestions"] += 1
    stats["today_suggestions"] += 1
    if user_id and str(user_id) in users:
        users[str(user_id)]["suggestions_count"] = users[str(user_id)].get("suggestions_count", 0) + 1
    save_stats(stats)
    save_users(users)


async def handle_media(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    if update.message.chat.type != "private":
        return
    user = update.effective_user
    user_id = user.id
    if not context.user_data.get("awaiting_suggestion", False):
        return
    update_suggestion_stats(user_id)
    media_type = "–§–û–¢–û"
    if update.message.video:
        media_type = "–í–ò–î–ï–û"
    elif update.message.document:
        media_type = "–î–û–ö–£–ú–ï–ù–¢"
    report_text = (
        f"üì• –ù–û–í–ê–Ø –ü–†–ï–î–õ–û–ñ–ö–ê (–ú–ï–î–ò–ê)\n"
        f"‚îú‚îÄ –û—Ç: {user.first_name} (@{user.username or '–±–µ–∑ username'})\n"
        f"‚îú‚îÄ ID: {user.id}\n"
        f"‚îî‚îÄ –¢–∏–ø: {media_type}\n"
    )
    try:
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text=report_text,
            message_thread_id=SUGGESTION_TOPIC_ID,
        )
        await update.message.forward(
            chat_id=ADMIN_CHAT_ID,
            message_thread_id=SUGGESTION_TOPIC_ID,
        )
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text="‚îÄ" * 40,
            message_thread_id=SUGGESTION_TOPIC_ID,
        )
        await update.message.reply_text(
            "‚úÖ –ü–æ–ª—É—á–∏–ª! –¢–≤–æ—è –ø—Ä–µ–¥–ª–æ–∂–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –°–ø–∞—Å–∏–±–æ! üí´",
            reply_markup=USER_KEYBOARD,
        )
        context.user_data["awaiting_suggestion"] = False
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_media: {e}")
        await update.message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    if update.message.chat.type != "private":
        return
    user = update.effective_user
    user_id = user.id
    msg_text = update.message.text

    # –ê–¥–º–∏–Ω‚Äë–∫–Ω–æ–ø–∫–∞ ¬´üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä¬ª
    if msg_text == "üîê –Ø –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä":
        if await is_admin(user_id):
            await update.message.reply_text(
                "‚úÖ <b>–î–æ—Å—Ç—É–ø –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!</b>\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è!",
                parse_mode="HTML",
                reply_markup=ADMIN_KEYBOARD,
            )
        else:
            await update.message.reply_text(
                "‚ùå <b>–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω</b>\n–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.",
                parse_mode="HTML",
                reply_markup=USER_KEYBOARD,
            )
        return

    if msg_text == "–û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º":
        await update.message.reply_text(
            "üîì <b>–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –≤ –æ–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return

    # –ó–∞–ø—É—Å–∫ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π
    if msg_text == "–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å":
        context.user_data["awaiting_suggestion"] = True
        await update.message.reply_text("üìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å–≤–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç (—Ç–µ–∫—Å—Ç, —Å–∫—Ä–∏–Ω –∏–ª–∏ —Ñ—Ä–∞–ø—Å)!")
        return

    if msg_text == "–ü–æ–º–æ—â—å":
        await update.message.reply_text(
            "‚ÑπÔ∏è <b>–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:</b>\n‚Ä¢ –ù–∞–∂–º–∏—Ç–µ '–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å'\n‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ\n‚Ä¢ –Ø –ø–µ—Ä–µ—à–ª—é –µ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º\nüìå –ö–æ–Ω—Ç–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–º!",
            parse_mode="HTML",
        )
        return

    # –ò–≥—Ä–∞ ¬´–õ–∞–±–∏—Ä–∏–Ω—Ç¬ª ‚Äì –ø–µ—Ä–µ–¥–∞—ë–º –∫–æ–º–∞–Ω–¥—É ConversationHandler
    if msg_text == "–ò–≥—Ä–∞—Ç—å –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç":
        return

    # –î–æ–ø. –∫–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–æ–≤
    if await is_admin(user_id):
        if msg_text == "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞":
            await show_statistics(update, context)
            return
        elif msg_text == "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏":
            await show_users(update, context)
            return
        elif msg_text == "–ù–∞—Å—Ç—Ä–æ–π–∫–∏":
            await show_settings(update, context)
            return
        elif msg_text == "–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç":
            return await create_post(update, context)

    # –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥ –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–µ–¥–ª–æ–∂–∫–∏
    if context.user_data.get("awaiting_suggestion", False):
        try:
            update_suggestion_stats(user_id)
            report_text = (
                f"üì• –ù–û–í–ê–Ø –ü–†–ï–î–õ–û–ñ–ö–ê\n"
                f"‚îú‚îÄ –û—Ç: {user.first_name} (@{user.username or '–±–µ–∑ username'})\n"
                f"‚îú‚îÄ ID: {user.id}\n"
                f"‚îî‚îÄ –¢–∏–ø: –¢–ï–ö–°–¢\n"
                f"üëá –°–û–î–ï–†–ñ–ò–ú–û–ï:\n{msg_text}\n"
            )
            await context.bot.send_message(
                chat_id=ADMIN_CHAT_ID,
                text=report_text,
                message_thread_id=SUGGESTION_TOPIC_ID,
            )
            await context.bot.send_message(
                chat_id=ADMIN_CHAT_ID,
                text="‚îÄ" * 40,
                message_thread_id=SUGGESTION_TOPIC_ID,
            )
            await update.message.reply_text(
                "‚úÖ –ü–æ–ª—É—á–∏–ª! –¢–≤–æ—è –ø—Ä–µ–¥–ª–æ–∂–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –°–ø–∞—Å–∏–±–æ! üí´",
                reply_markup=USER_KEYBOARD,
            )
            context.user_data["awaiting_suggestion"] = False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ handle_message: {e}")
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return


# --------------------------------------------------------------------------
# 10. –°—Ç–∞—Ä—Ç –∏ –æ—Ç–ª–∞–¥–∫–∞
# --------------------------------------------------------------------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.effective_user:
        return
    if update.message.chat.type != "private":
        return
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    update_user_stats(user_id, user_name)
    welcome_text = f"–ü—Ä–∏–≤–µ—Ç, {user_name}! üëã\n–Ø –±–æ—Ç –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:"
    await update.message.reply_text(welcome_text, reply_markup=USER_KEYBOARD)


async def debug_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not await is_admin(update.effective_user.id):
        return
    mirror_map = load_mirror_map()
    debug_text = (
        "üìä <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏:</b>\n"
        f"üîß ID –∫–∞–Ω–∞–ª–∞: <code>{CHANNEL_CHAT_ID}</code>\n"
        f"üîß ID —á–∞—Ç–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤: <code>{COMMENTS_CHAT_ID}</code>\n"
        f"üîß ID –≥—Ä—É–ø–ø—ã –ø—Ä–µ–¥–ª–æ–∂–µ–∫: <code>{GROUP_CHAT_ID}</code>\n"
        f"üîß Username –∫–∞–Ω–∞–ª–∞: @{CHANNEL_USERNAME}\n"
        f"üîó –°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ —Å–≤—è–∑–∫–∏ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 5):\n"
    )
    for k, v in list(mirror_map.items())[-5:]:
        debug_text += f"\n‚Ä¢ –ö–∞–Ω–∞–ª {k} ‚Üí –ß–∞—Ç {v}"
    if not mirror_map:
        debug_text += "\n–ü–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —Å–≤—è–∑–æ–∫"
    await update.message.reply_text(debug_text, parse_mode="HTML")


async def show_statistics(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not await is_admin(update.effective_user.id):
        return
    users = load_users()
    cutoff = (datetime.now() - timedelta(days=6)).strftime("%Y-%m-%d")
    ranking = []
    for uid, u in users.items():
        msg_counts = u.get("msg_counts", {})
        total7 = sum(int(cnt) for day, cnt in msg_counts.items() if day >= cutoff)
        if total7 > 0:
            ranking.append((total7, int(uid), u.get("name") or uid))
    ranking.sort(reverse=True, key=lambda x: x[0])
    if not ranking:
        await update.message.reply_text("–ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ.")
        return
    lines = ["–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —á–∞—Ç–∞ –∑–∞ 7 –¥–Ω–µ–π (—á–∞—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤):"]
    for idx, (cnt, uid, name) in enumerate(ranking, start=1):
        lines.append(f"{idx}. {name} (id {uid}): {cnt}")
    await update.message.reply_text("\n".join(lines[:100]))


async def show_users(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üë• –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")


async def show_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")


# --------------------------------------------------------------------------
# 11. –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–∞
# --------------------------------------------------------------------------
async def create_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user or not await is_admin(update.effective_user.id):
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å—Ç–æ–≤.")
        return ConversationHandler.END
    await update.message.reply_text("üìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞:")
    return GET_TEXT


async def get_post_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["post_text"] = update.message.text
    await update.message.reply_text(
        "üìé –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–Ω–æ–ø–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "`–ö–Ω–æ–ø–∫–∞ 1 - https://example.com`\n"
        "–ö–∞–∂–¥–∞—è –∫–Ω–æ–ø–∫–∞ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.\n"
        "–ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ '–ë–µ–∑ –∫–Ω–æ–ø–æ–∫'.",
        parse_mode="HTML",
    )
    return GET_BUTTONS


async def process_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = context.user_data.get("post_text", "–¢–µ–∫—Å—Ç –Ω–µ –∑–∞–¥–∞–Ω")
    buttons_text = update.message.text
    reply_markup = None
    if buttons_text.strip().lower() != "–±–µ–∑ –∫–Ω–æ–ø–æ–∫":
        try:
            button_rows = []
            for line in buttons_text.split("\n"):
                if " - " in line:
                    label, url = line.split(" - ", 1)
                    button_rows.append(
                        [InlineKeyboardButton(label.strip(), url=url.strip())]
                    )
            if button_rows:
                reply_markup = InlineKeyboardMarkup(button_rows)
        except Exception:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∫–Ω–æ–ø–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return GET_BUTTONS
    try:
        sent = await context.bot.send_message(
            chat_id=CHANNEL_CHAT_ID,
            text=text,
            reply_markup=reply_markup,
            disable_web_page_preview=False,
        )
        add_post_to_history(sent.message_id, text)
        await update.message.reply_text("‚úÖ –ü–æ—Å—Ç —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –≤ –∫–∞–Ω–∞–ª–µ!")
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {str(e)}")
    return ConversationHandler.END


async def cancel_creation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    return ConversationHandler.END


# --------------------------------------------------------------------------
# 12. –õ–∞–±–∏—Ä–∏–Ω—Ç ‚Äì –ª–æ–≥–∏–∫–∞ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
# --------------------------------------------------------------------------
class LabyrinthState:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.hp = LABYRINTH_START_HP
        self.step = 0
        self.messages = []  # message_id, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å
        self.last_labyrinth = None  # YYYY‚ÄëMM‚ÄëDD
        self.wins = 0
        self.loses = 0


def load_laby_state(uid: int) -> LabyrinthState:
    users = load_users()
    u = users.get(str(uid), {})
    state = LabyrinthState(uid)
    state.hp = u.get("labyrinth_hp", LABYRINTH_START_HP)
    state.step = u.get("labyrinth_step", 0)
    state.last_labyrinth = u.get("last_labyrinth")
    state.wins = u.get("labyrinth_wins", 0)
    state.loses = u.get("labyrinth_loses", 0)
    return state


def save_laby_state(state: LabyrinthState):
    users = load_users()
    u = users.get(str(state.user_id), {})
    u.update(
        {
            "labyrinth_hp": state.hp,
            "labyrinth_step": state.step,
            "last_labyrinth": state.last_labyrinth,
            "labyrinth_wins": state.wins,
            "labyrinth_loses": state.loses,
        }
    )
    users[str(state.user_id)] = u
    save_users(users)


# --------------------------------------------------------------------------
# 13. Helper –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∑–∞–ø–∏—Å–∏ ID
# --------------------------------------------------------------------------
async def send_and_record(update: Update, context: ContextTypes.DEFAULT_TYPE,
                          state: LabyrinthState, text: str,
                          image: str | None = None,
                          reply_markup=None, parse_mode="HTML"):
    msg_id = await send_message_with_cleanup(
        update, context, text, image, reply_markup, parse_mode
    )
    if state:
        state.messages.append(msg_id)
    return msg_id


# --------------------------------------------------------------------------
# 14. –§—É–Ω–∫—Ü–∏–∏ –ø—Ä–∞–≤–∏–ª –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
# --------------------------------------------------------------------------
async def start_labyrinth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    state = load_laby_state(user_id)

    today = datetime.now().strftime("%Y-%m-%d")
    if LABYRINTH_DAILY_LIMIT_ENABLED and state.last_labyrinth == today:
        await update.message.reply_text("–í—ã —É–∂–µ –∏–≥—Ä–∞–ª–∏ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –ø–æ–∫–∞ —Å–º–µ–Ω–∏—Ç—Å—è –¥–µ–Ω—å.")
        return ConversationHandler.END

    # Reset state
    state.hp = LABYRINTH_START_HP
    state.step = 0
    state.last_labyrinth = today
    state.messages = []
    save_laby_state(state)

    msgs = load_messages()
    greet = msgs["greetings"][0]
    if state.wins + state.loses == 0:
        greet_text, greet_img = greet["first_time"]["text"], greet["first_time"]["image"]
    else:
        greet_text, greet_img = greet["subsequent"]["text"], greet["subsequent"]["image"]

    greet_text = f"üí™ HP: {state.hp}\n{resolve_placeholders(greet_text, msgs['placeholders'])}"
    markup = ReplyKeyboardMarkup(
        [["–•–æ—á—É –≥–æ–ª–¥—É"], ["–ù–µ —Ö–æ—á—É –≥–æ–ª–¥—É"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
    )
    await send_and_record(update, context, state, greet_text, greet_img, markup)
    return LABYRINTH_GAME


async def labyrinth_handle_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    state = load_laby_state(user_id)
    choice = update.message.text.strip()
    msgs = load_messages()

    # –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é
    if choice == "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é":
        for msg_id in state.messages:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id, message_id=msg_id
                )
            except Exception:
                pass
        state.messages = []
        save_laby_state(state)
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return ConversationHandler.END

    # 1. –ù–µ —Ö–æ—á—É –≥–æ–ª–¥—É ‚Üí –ø–æ—Ä–∞–∂–µ–Ω–∏–µ ‚Ññ1
    if choice == "–ù–µ —Ö–æ—á—É –≥–æ–ª–¥—É":
        state.loses += 1
        state.hp = LABYRINTH_START_HP
        await send_defeat(update, context, state, reason="not_desire")
        for msg_id in state.messages:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id, message_id=msg_id
                )
            except Exception:
                pass
        state.messages = []
        save_laby_state(state)
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return ConversationHandler.END

    # 2. –•–æ—á—É –≥–æ–ª–¥—É ‚Üí —Å–æ–±—ã—Ç–∏–µ
    if choice == "–•–æ—á—É –≥–æ–ª–¥—É":
        await handle_event(update, context, state, msgs)
        save_laby_state(state)
        return LABYRINTH_GAME

    # 3. –ü—Ä–æ–π—Ç–∏ –º–∏–º–æ ‚Üí —Å–æ–±—ã—Ç–∏–µ –±–µ–∑ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ
    if choice == "–ü—Ä–æ–π—Ç–∏ –º–∏–º–æ":
        await handle_event(update, context, state, msgs, skip_special=True)
        save_laby_state(state)
        return LABYRINTH_GAME

    # 4. –°–º–µ—Ä—Ç—å ‚Üí –ø–æ—Ä–∞–∂–µ–Ω–∏–µ ‚Ññ2
    if choice == "–°–º–µ—Ä—Ç—å":
        state.loses += 1
        state.hp = LABYRINTH_START_HP
        await send_defeat(update, context, state, reason="special_death")
        for msg_id in state.messages:
            try:
                await context.bot.delete_message(
                    chat_id=update.effective_chat.id, message_id=msg_id
                )
            except Exception:
                pass
        state.messages = []
        save_laby_state(state)
        await update.message.reply_text(
            "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
        )
        return ConversationHandler.END

    # 5. –î–≤–∏–∂–µ–Ω–∏—è
    if choice in ("–ù–∞–ª–µ–≤–æ", "–í–ø–µ—Ä–µ–¥", "–ù–∞–ø—Ä–∞–≤–æ"):
        state.step += 1
        if state.step >= LABYRINTH_MAX_STEPS:
            await send_victory(update, context, state, msgs)
            state.wins += 1
            state.hp = LABYRINTH_START_HP
            for msg_id in state.messages:
                try:
                    await context.bot.delete_message(
                        chat_id=update.effective_chat.id, message_id=msg_id
                    )
                except Exception:
                    pass
            state.messages = []
            save_laby_state(state)
            await update.message.reply_text(
                "üîì <b>–í–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", parse_mode="HTML", reply_markup=USER_KEYBOARD
            )
            return ConversationHandler.END
        await handle_event(update, context, state, msgs)
        save_laby_state(state)
        return LABYRINTH_GAME

    return LABYRINTH_GAME


async def handle_event(update: Update, context: ContextTypes.DEFAULT_TYPE,
                      state: LabyrinthState, msgs: dict,
                      skip_special: bool = False):
    probs = {
        1: 0.20,
        2: 0.09,
        3: 0.11,
        4: 0.2475,
        5: 0.1925,
        6: 0.11,
    }
    if not skip_special:
        probs[7] = 0.05
    items, weights = zip(*probs.items())
    sel = random.choices(items, weights=weights)[0]

    if sel == 7:  # Special
        tmpl = random.choice(msgs["events"]["special"])
        text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
        msg_text = f"{text}\nüí™ HP: {state.hp}"
        markup = ReplyKeyboardMarkup(
            [["–ü—Ä–æ–π—Ç–∏ –º–∏–º–æ"], ["–°–º–µ—Ä—Ç—å"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
        )
        await send_and_record(update, context, state, msg_text, tmpl["image"], markup)
        return

    events = msgs["events"][str(sel)]
    tmpl = random.choice(events)
    delta = 0
    effect = None
    if sel == 2:
        delta = 2
        effect = "(+2 HP)"
    elif sel == 3:
        delta = 1
        effect = "(+1 HP)"
    elif sel == 4:
        delta = -1
        effect = "(-1 HP)"
    elif sel == 5:
        delta = -2
        effect = "(-2 HP)"
    elif sel == 6:
        delta = -3
        effect = "(-3 HP)"
    state.hp += delta

    if state.hp <= 0:
        state.loses += 1
        state.hp = LABYRINTH_START_HP
        await send_defeat(update, context, state, reason="hp_zero")
        return

    text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
    msg_text = f"{text}\nüí™ HP: {state.hp}\n{effect if effect else ''}"
    markup = ReplyKeyboardMarkup(
        [["–ù–∞–ª–µ–≤–æ"], ["–í–ø–µ—Ä–µ–¥"], ["–ù–∞–ø—Ä–∞–≤–æ"], ["–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é"]], one_time_keyboard=True
    )
    await send_and_record(update, context, state, msg_text, tmpl["image"], markup)


async def send_defeat(update: Update, context: ContextTypes.DEFAULT_TYPE,
                     state: LabyrinthState, reason: str):
    msgs = load_messages()
    if reason == "not_desire":
        tmpl = random.choice(msgs["defeat1"])
    elif reason == "special_death":
        tmpl = random.choice(msgs["defeat2"])
    else:
        tmpl = random.choice(msgs["defeat"])
    text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
    msg_text = f"{text}\n‚ö†Ô∏è HP: {state.hp}"
    await send_and_record(update, context, state, msg_text, tmpl["image"])


async def send_victory(update: Update, context: ContextTypes.DEFAULT_TYPE,
                       state: LabyrinthState, msgs: dict):
    tmpl = random.choice(msgs["victory"])
    text = resolve_placeholders(tmpl["text"], msgs["placeholders"])
    msg_text = f"{text}\nüèÜ HP: {state.hp}"
    await send_and_record(update, context, state, msg_text, tmpl["image"])
    promo = get_daily_promo()
    if promo:
        await update.message.reply_text(
            f"üéÅ –¢–≤–æ–π –ø—Ä–æ–º–æ–∫–æ–¥: <code>{promo}</code>", parse_mode="HTML"
        )
    else:
        await update.message.reply_text(
            "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–º–æ–∫–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å, –Ω–æ –≤—ã –≤—Å–µ —Ä–∞–≤–Ω–æ –º–æ–ª–æ–¥–µ—Ü!"
        )


# --------------------------------------------------------------------------
# 15. –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
# --------------------------------------------------------------------------
async def send_message_with_cleanup(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                   text: str,
                                   image: str | None = None,
                                   reply_markup=None,
                                   parse_mode="HTML"):
    chat_id = update.effective_chat.id
    if image and os.path.exists(os.path.join("images", image)):
        with open(os.path.join("images", image), "rb") as f:
            sent = await context.bot.send_photo(
                chat_id=chat_id,
                photo=f,
                caption=text,
                parse_mode=parse_mode,
                reply_markup=reply_markup,
            )
    else:
        sent = await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            parse_mode=parse_mode,
            reply_markup=reply_markup,
        )
    asyncio.create_task(schedule_delete(context, chat_id, sent.message_id))
    return sent.message_id


async def schedule_delete(context: ContextTypes.DEFAULT_TYPE, chat_id: int, msg_id: int):
    await asyncio.sleep(120)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
    except Exception:
        pass


# --------------------------------------------------------------------------
# 16. –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
# --------------------------------------------------------------------------
def main():
    # –°–æ–∑–¥–∞—ë–º –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
    for path, default in [
        (STATS_FILE, load_stats()),
        (USERS_FILE, {}),
        (POSTS_FILE, {}),
        (MIRROR_MAP_FILE, {}),
    ]:
        if not os.path.exists(path):
            if isinstance(default, set):
                default = list(default)
            with open(path, "w", encoding="utf-8") as f:
                json.dump(default, f, ensure_ascii=False, indent=2)

    if not os.path.exists("images"):
        os.makedirs("images")
        print("üìÅ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ 'images'")

    app = Application.builder().token(BOT_TOKEN).build()

    # –ö–∞–Ω–∞–ª/–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
    app.add_handler(
        MessageHandler(filters.Chat(COMMENTS_CHAT_ID), handle_chat_message)
    )
    app.add_handler(
        MessageHandler(filters.ChatType.CHANNEL, handle_channel_post)
    )
    app.add_handler(
        MessageHandler(
            filters.Chat(COMMENTS_CHAT_ID) & ~filters.StatusUpdate.ALL,
            handle_group_message_stats
        )
    )

    # –õ–∞–±–∏—Ä–∏–Ω—Ç
    labyrinth_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^–ò–≥—Ä–∞—Ç—å –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç$"), start_labyrinth)],
        states={LABYRINTH_GAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, labyrinth_handle_choice)]},
        fallbacks=[],
        allow_reentry=True,
    )
    app.add_handler(labyrinth_conv)

    # –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–æ–≤
    post_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç$"), create_post)],
        states={
            GET_TEXT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_post_text)],
            GET_BUTTONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_buttons)],
        },
        fallbacks=[MessageHandler(filters.Regex("^–û—Ç–º–µ–Ω–∏—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ$"), cancel_creation)],
        allow_reentry=True,
    )
    app.add_handler(post_conv)

    # –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã –∏ —Å–æ–æ–±—â–µ–Ω–∏—è
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("debug", debug_info))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(
        MessageHandler(
            filters.PHOTO | filters.VIDEO | filters.Document.ALL,
            handle_media
        )
    )

    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    app.run_polling()


if __name__ == "__main__":
    main()
